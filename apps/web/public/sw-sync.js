/**
 * Service Worker - Background Sync Handler
 * This file is injected into the service worker generated by vite-plugin-pwa
 * Handles 'sync' events to process the offline queue when connection is restored
 */

// Listen for sync events
self.addEventListener('sync', (event) => {
  console.log('[ServiceWorker] Sync event received:', event.tag);
  
  if (event.tag === 'offline-queue-sync') {
    event.waitUntil(processOfflineQueue());
  }
});

/**
 * Process the offline queue
 */
async function processOfflineQueue() {
  console.log('[ServiceWorker] Processing offline queue...');
  
  try {
    // Open IndexedDB to get pending actions
    const db = await openOfflineQueueDB();
    const actions = await getPendingActionsFromDB(db);
    
    console.log('[ServiceWorker] Found', actions.length, 'pending actions');
    
    if (actions.length === 0) {
      return true;
    }
    
    // Process each action
    let processed = 0;
    let failed = 0;
    
    for (const action of actions) {
      const success = await processActionInSW(action);
      if (success) {
        processed++;
        // Remove from DB
        await removeActionFromDB(db, action.id);
      } else {
        failed++;
      }
    }
    
    console.log('[ServiceWorker] Processed:', processed, 'Failed:', failed);
    
    // Notify all clients about sync completion
    const clients = await self.clients.matchAll();
    clients.forEach(client => {
      client.postMessage({
        type: 'SYNC_COMPLETE',
        tag: 'offline-queue-sync',
        success: failed === 0,
        processed,
        failed,
      });
    });
    
    return failed === 0;
  } catch (error) {
    console.error('[ServiceWorker] Failed to process queue:', error);
    return false;
  }
}

/**
 * Open the offline queue IndexedDB
 */
function openOfflineQueueDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('torretempo-offline-queue', 1);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
  });
}

/**
 * Get all pending actions from IndexedDB
 */
function getPendingActionsFromDB(db) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['actions'], 'readonly');
    const store = transaction.objectStore('actions');
    const index = store.index('by-status');
    const request = index.getAll('pending');
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
  });
}

/**
 * Remove action from IndexedDB
 */
function removeActionFromDB(db, actionId) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['actions'], 'readwrite');
    const store = transaction.objectStore('actions');
    const request = store.delete(actionId);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve();
  });
}

/**
 * Update action status in IndexedDB
 */
function updateActionStatusInDB(db, actionId, status, error) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['actions'], 'readwrite');
    const store = transaction.objectStore('actions');
    const getRequest = store.get(actionId);
    
    getRequest.onerror = () => reject(getRequest.error);
    getRequest.onsuccess = () => {
      const action = getRequest.result;
      if (!action) {
        resolve();
        return;
      }
      
      action.status = status;
      action.retryCount = (action.retryCount || 0) + 1;
      if (error) {
        action.error = error;
      }
      
      const putRequest = store.put(action);
      putRequest.onerror = () => reject(putRequest.error);
      putRequest.onsuccess = () => resolve();
    };
  });
}

/**
 * Process a single action via fetch
 */
async function processActionInSW(action) {
  console.log('[ServiceWorker] Processing action:', action.id, action.type);
  
  try {
    let url, method, body;
    
    // Build API request based on action type
    switch (action.type) {
      case 'clock-in':
        url = `https://time.lsltgroup.es/api/v1/org/${action.organizationSlug}/time-entries/clock-in`;
        method = 'POST';
        body = JSON.stringify(action.data);
        break;
        
      case 'clock-out':
        url = `https://time.lsltgroup.es/api/v1/org/${action.organizationSlug}/time-entries/${action.data.entryId}/clock-out`;
        method = 'POST';
        body = JSON.stringify(action.data);
        break;
        
      case 'start-break':
        url = `https://time.lsltgroup.es/api/v1/org/${action.organizationSlug}/time-entries/${action.data.entryId}/breaks`;
        method = 'POST';
        body = JSON.stringify(action.data);
        break;
        
      case 'end-break':
        url = `https://time.lsltgroup.es/api/v1/org/${action.organizationSlug}/time-entries/${action.data.entryId}/breaks/${action.data.breakId}/end`;
        method = 'POST';
        body = JSON.stringify(action.data);
        break;
        
      default:
        throw new Error(`Unknown action type: ${action.type}`);
    }
    
    // Make API request
    const response = await fetch(url, {
      method,
      headers: {
        'Content-Type': 'application/json',
      },
      body,
      credentials: 'include', // Include cookies for authentication
    });
    
    if (!response.ok) {
      throw new Error(`API request failed: ${response.status} ${response.statusText}`);
    }
    
    console.log('[ServiceWorker] Action processed successfully:', action.id);
    return true;
  } catch (error) {
    console.error('[ServiceWorker] Failed to process action:', action.id, error);
    
    // Update status in DB (mark as failed after 3 retries)
    const db = await openOfflineQueueDB();
    const retryCount = action.retryCount || 0;
    
    if (retryCount >= 2) {
      await updateActionStatusInDB(db, action.id, 'failed', error.message);
      // Remove from queue after max retries
      await removeActionFromDB(db, action.id);
    } else {
      await updateActionStatusInDB(db, action.id, 'pending', error.message);
    }
    
    return false;
  }
}
